{\rtf1\ansi\ansicpg936\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset134 HannotateSC-W5;\f1\fmodern\fcharset0 Courier-Bold;\f2\fnil\fcharset0 MicrosoftYaHei;
\f3\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red38\green48\blue38;}
\paperw11900\paperh16840\margl1440\margr1440\vieww20120\viewh15860\viewkind0
\deftab720
\pard\pardeftab720\sl340\partightenfactor0

\f0\b\fs36 \cf0 \expnd0\expndtw0\kerning0
The reset command. Confusing. Misunderstood. Misused. But it doesn\'a1\'aft need to be that way! It\'a1\'afs really not too confusing once you figure out what\'a1\'afs going on.\
\pard\pardeftab720\sl340\sa240\partightenfactor0
\cf0 First, let\'a1\'afs define a few terms.\
\pard\pardeftab720\sl340\partightenfactor0
\cf0 HEAD:This is an alias for the tip of the current\uc0\u160 branch, which is the most recent commit you have made to that branch.\
\
INDEX:The index, also known as the staging area, is the set of\uc0\u160 files that will become the next commit. It is also the commit that\u160 will become\u160 HEAD\'a1\'afs parent.\
\
WORKING COPY:This is the term for the current set of files you\'a1\'afre working on in your file system.\
\
\
Flow:\
When you first checkout a branch, HEAD points to the most recent commit in the branch. The files in the HEAD (they aren\'a1\'aft technically files, they\'a1\'afre blobs but for the purposes of this discussion we can think of them as straight files) match that of the files in the index, and the files checked out in your working copy match HEAD and the index as well. All 3 are in an equal state, and Git is happy.\
Then, when you do a\uc0\u160 
\f1 git add
\f0 , it stages the file in the index, and Git says \'a1\'b0oh, okay, now your working copy and index match, but those are both different than HEAD.\'a1\'b1\
When you then perform a\uc0\u160 
\f1 git commit
\f0 , Git creates a new commit that HEAD now points to and the status of the index and working copy match it so Git\'a1\'afs happy once more.\
\pard\pardeftab720\sl500\sa298\partightenfactor0
\cf0 Reset\
\pard\pardeftab720\sl340\sa240\partightenfactor0
\cf0 If you just look at the reset command by itself, all it does is reset HEAD (the tip of the current branch) to another commit. For instance, say we have a branch (the name doesn\'a1\'aft matter, so let\'a1\'afs call this one \'a1\'b0super-duper-feature\'a1\'b1) and it looks like so:\
\pard\pardeftab720\sl340\sa240\partightenfactor0
\cf0 {{\NeXTGraphic 燎쀦린.png \width2850 \height6870
}샇\pard\pardeftab720\sl340\sa240\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\sa100\partightenfactor0

\f2\b0 \cf2 If we start at the latest commit again and do:\
\pard\pardeftab720\sl320\partightenfactor0

\f1\b \cf2 > git\'a0reset\'a0HEAD~2\
\pard\pardeftab720\sl420\sa100\partightenfactor0

\f2\b0 \cf2 our branch would look like so:\
\pard\pardeftab720\sl340\sa240\partightenfactor0

\f0\b \cf0 {{\NeXTGraphic 1__#$!@%!#__燎쀦린.png \width2850 \height6870
}샇\pard\pardeftab720\sl340\sa240\partightenfactor0
\cf0 \
\pard\pardeftab720\sl420\sa100\partightenfactor0

\f2\b0 \cf2 Again, all it does on a basic level is move HEAD to another commit.\
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \uc0\u8232 \
Parameters\
\pard\pardeftab720\sl340\partightenfactor0

\f0\b \cf0 So the reset command itself is pretty simple, but it\'a1\'afs the parameters that cause confusion. The main parameters are\uc0\u160 
\f1 soft
\f0 ,\uc0\u160 
\f1 hard
\f0 \uc0\u160 and\u160 
\f1 mixed
\f0 . These tell Git what to do with your index and working copy when performing the reset.\
\
\pard\pardeftab720\sl380\partightenfactor0

\f2\b0 \cf2 Soft\
\pard\pardeftab720\sl340\partightenfactor0

\f0\b \cf0 parameter tells Git to reset HEAD to another commit, but that\'a1\'afs it. If you specify\uc0\u160 
\f1 --soft
\f0 \uc0\u160 Git will stop there and nothing else will change. What this means is that the index and working copy don\'a1\'aft get touched, so all of the files that changed between the original HEAD and the commit you reset to appear to be staged.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 {{\NeXTGraphic reset-wc-index-changed.png \width8700 \height2040
}샇
\f0\b\fs36 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\sl400\sa280\partightenfactor0
\cf0 Mixed (default)\
\pard\pardeftab720\sl340\partightenfactor0
\cf0 parameter (which is the default if you don\'a1\'aft specify anything) will reset HEAD to another commit,\uc0\u160 and\u160 will reset the index to match it, but will stop there. The working copy will not be touched. So, all of the changes between the original HEAD and the commit you reset to are still in the working copy and appear as modified, but not staged.\
\pard\pardeftab720\sl340\sa240\partightenfactor0
\cf0 {{\NeXTGraphic 2__#$!@%!#__燎쀦린.png \width8700 \height2040
}샇\pard\pardeftab720\sl340\sa240\partightenfactor0
\cf0 \
\pard\pardeftab720\sl380\partightenfactor0

\f2\b0 \cf2 Hard\
\pard\pardeftab720\sl340\partightenfactor0

\f0\b \cf0 parameter will blow out everything \'a8\'43 it resets HEAD back to another commit, resets the index to match it,\uc0\u160 and\u160 resets the working copy to match it as well. This is the more dangerous of the commands and is where you can cause damage. Data might get lost here*!\
\pard\pardeftab720\sl340\sa240\partightenfactor0
\cf0 {{\NeXTGraphic 3__#$!@%!#__燎쀦린.png \width8700 \height2040
}샇\pard\pardeftab720\sl340\sa240\partightenfactor0
\cf0 \
* You can recover it using\uc0\u160 
\f1 git reflog
\f0 \uc0\u160 but that\'a1\'afs out of scope here.\
}